由於http協議是無狀態無連接的，因此，服務器端並不能感知客戶端（如瀏覽器）的存在，每一次交互，都是由客戶端發起，服務器端收到消息後響應，返回消息給客戶端，完成。題主要做的所謂實時更新，其實核心問題是：服務器端如何向客戶端推送消息。這個問題常用方式三種，簡單說下：
1.客戶端輪詢。這個簡單，就是客戶端每隔一段時間，向服務器端發起請求，要求接受更新的數據。這其實是假推送，實際上，還是客戶端定期去問，不過是自動化的，不需要用戶發起更新操作，在實時性不太強的場合可以使用。
2.長連接。這個是很有趣的方法。我們知道，http請求由客戶端發起，然後服務器端響應，或者超時···長連接的意思很簡單，你發起請求後，不設置超時，服務器端接到請求後，不立刻返回，而是阻塞請求，知道有更新了，再返回數據。好比我有一部電話，只能接不能打，你希望我這邊有了新的商品後通知你，要么像第一種輪詢方式一樣，你隔一段時間打過來問問；或者就是長連接，你打過來，我不回答你，也不掛電話，直到我這兒來了新的商品，我再說一句：京東上新拉,快下單吧。然後掛掉電話。你那邊接到這句話後，下單買東西，同時立刻再打過來：京東有新貨了嗎？然後我接你的電話，默不作聲····直到兩天后，又有新的商品來了，我再喊一句：京東上新拉~~快下單···循環往復，這就是長連接。
3.websocket。這個其實已經超出了http的範圍了，實際上就是瀏覽器端，實現了socket協議，直接採用socket方式通信了。



整個過程可以分為5個環節：1 包裝數據、2 觸發通知、3 通訊傳輸、4 解析數據、5 渲染數據。這5個環節中有三點很關鍵：
1 通訊通道選擇、2 數據格式定義、3 渲染數據。 

1 通訊通道選擇：這個很多前端高手已經回答了，基本就是兩種方式：輪詢和長連接，這種情況通常的解決方式是長連接，Web端可以用WebSocket來解決，這也是業界普遍採用的方案，比如環信、用友有信、融雲等等。通訊環節是相當耗費服務器資源的一個環節，而且開發成本偏高，建議將這些第三方的平台直接集成到自己的項目中，以降低開發的成本。 

2 數據格式定義：數據格式可以定義得五花八門，不過為了前端的解析，建議外層統一數據格式，定義一個類似type的屬性來標記數據屬性（是IM消息、微博數據還是發貨通知），然後定義一個data屬性來記錄數據的內容（一般對應數據表中的一行數據）。統一數據格式後，前端解析數據的成本會大大降低。 

3 渲染數據渲染數據是關係到前端架構的，比如是React、Vue還是Angular（BTW：不要用Angular，個人認為Angular在走向滅亡）。這些框架都用到了數據綁定，這已經成為業界的共識了（只需要對數據進行操作，不需要操作DOM），這點不再論述。在此種需求場景下，數據流會是一個比較大的問題，因為可能每一條新數據都需要尋找對應的組件去傳遞數據，這個過程會特別噁心。所以選擇單一樹的數據流應該會很合適，這樣只需要對一棵樹的節點進行操作即可：定義好type和樹節點的對應關係，然後直接定位到對應的節點對數據增刪改就可以，例如Redux。